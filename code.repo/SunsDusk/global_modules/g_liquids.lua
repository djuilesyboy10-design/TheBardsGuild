openBottles = {
--	["misc_com_bottle_06"] = true,
--	["misc_com_bottle_09"] = true,
--	["misc_com_bottle_11"] = true,
--	["misc_com_bottle_13"] = true,
--	["misc_com_bottle_13"] = true,
--	["misc_com_bottle_02"] = true,
--	["misc_com_bottle_01"] = true,
	-- Starwind
}
extraClosedBottles = {
	["misc_com_redware_flask"] = true,
	["ab_misc_waterskin"]	   = true,
}

-- maxVolumeQ: only vessels with Q <= this can roll the liquid
-- spawnChance: relative weight
-- valuePerQ: value added per Q

-- ALSO ADD TO localizedLiquidNames !!!
local LIQUIDS = {
	water = {
		templateId  = 'sd_waterbottle_template',
		displayName = 'Water',
		maxVolumeQ  = math.huge,
		spawnChance = 1.0,
		valuePerQ   = 1,
	},
	saltWater = {
		templateId  = 'sd_saltwater_template',
		displayName = 'Saltwater',
		maxVolumeQ  = 0,
		spawnChance = 0,
		valuePerQ   = 1,
	},
	susWater = {
		templateId  = 'sd_suswater_template',
		displayName = 'Suspicious Water',
		maxVolumeQ  = 0,
		spawnChance = 0,
		valuePerQ   = 1,
	},
	sujamma = {
		templateId  = 'sd_sujamma_template',
		displayName = 'Sujamma',
		maxVolumeQ  = 2,	-- Q<=2 (<=500 ml per Q step*2) by default
		spawnChance = 0.3,  -- less common than water
		valuePerQ   = 6,	-- pricier kick
	},
	flin = {
		templateId  = 'sd_flin_template',
		displayName = 'Flin',
		maxVolumeQ  = 1,	-- Q<=1 (<=250 ml per Q step*2) by default
		spawnChance = 0.15, -- less common than sujamma
		valuePerQ   = 10,	-- pricier kick
	},
	-- Starwind: sd_bluemilk_template ; sd_bluebooze_template ; sd_banthamilk_template
	tea_SF = {
		templateId  = 'sd_tea_sf_template',
		displayName = 'Stoneflower Tea', -- name of the liquid
		maxVolumeQ  = 0,	-- not appearing randomly
		spawnChance = 0.80, -- ignored then
		valuePerQ   = 40,	-- pricy
	},
	tea_H = {
		templateId  = 'sd_tea_h_template',
		displayName = 'Heather Tea', -- name of the liquid
		maxVolumeQ  = 0,	-- not appearing randomly
		spawnChance = 0.80, -- ignored then
		valuePerQ   = 40,	-- pricy
	},
--[[	tea_CR = {
		templateId  = 'sd_tea_cr_template',
		displayName = 'Canit Root Tea', -- name of the liquid
		maxVolumeQ  = 0,	-- not appearing randomly
		spawnChance = 0.80, -- ignored then
		valuePerQ   = 40,	-- pricy
	},
]]	
}
-- teacup - Misc_Com_Redware_Cup ; AB_Misc_DeCeramicCup_02 // teapot - ceramicteapot ; AB_Misc_kettleceremonial ; AB_Misc_debugteapot

local vesselLiquids = {
	["misc_com_redware_cup"] 		= { "tea_SF", "tea_H" },
	["misc_de_pot_redware_03"] 		= { "tea_SF", "tea_H" },
--	["t_com_copperkettle_01"] 		= { "tea_SF", "tea_H" },
--	["t_com_coppetteapot_01"] 		= { "tea_SF", "tea_H" },
	["ab_misc_deceramiccup_01"] 	= { "tea_SF", "tea_H" },	
	["ab_misc_deceramiccup_02"] 	= { "tea_SF", "tea_H" },
	["ab_misc_deceramicflask_01"] 	= { "tea_SF", "tea_H" },	
--	["ab_misc_kettleceremonial"] 	= { "tea_SF", "tea_H" },
--	["ab_misc_debugteapot"] 		= { "tea_SF", "tea_H" },	
}
local unspillableLiquids = {
	'stoneflower tea',
	'heather tea',
--	'canis root tea',
}

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Constants															  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local STEP_ML = 250

-- substrings -> fallback liters
local FALLBACK_LITERS = {
	bottle  		= 1.0,
	flask   		= 0.5,
	beaker  		= 0.5,
	cup	 			= 0.25,
	misc_de_glass   = 0.25,
	goblet  		= 0.25,
	pitcher 		= 0.75,
	tankard 		= 0.5,
	vase			= 2.0,
	bucket			= 4.0,
	teapot			= 1.0,
}

local ZERO_CHANCE_SUBSTRINGS = { 'bucket' }
local LOW_CHANCE_SUBSTRINGS  = { 'vase', 'pot' }
local SUBSTRINGS			 = { 
	'flask', 
	'beaker', 
	'cup', 
	'goblet', 
	'pitcher', 
	'tankard', 
	'misc_de_glass', 
	'drinkinghorn', 
	't_com_potionbottle_',
	'vial',
	'mug',
}
local INVENTORY_SUBSTRINGS   = { 'bottle', 'canteen', 'misc_flask_03', 'waterskin' }
local BLACKLIST_SUBSTRINGS   = { 'broken' }

-- Starwind

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Utils																  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function hasKeyword(hay, kw)
	if not hay then
		return false
	end
	return string.find(hay, kw, 1, true) ~= nil
end

-- Trim trailing zeros from decimal strings.
local function trimZeros(num)
	-- num is number
	local n = math.floor(num * 100 + 0.5) / 100
	local s = tostring(n)
	if string.find(s, "%.") then
		s = s:gsub("0+$", "")
		s = s:gsub("%.$", "")
	end
	return s
end



-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Vessel Types 														  │
-- ╰──────────────────────────────────────────────────────────────────────╯

-- Returns (chance, avgFill) or false.
local function isVesselRecord(rec, isSealed)
	if not rec then
		return false
	end

	local id   = rec.id
	local name = (rec.name or ''):lower()

	-- Avoid scripted items to prevent conflicts
	if rec.mwscript then
		return false
	end
	
	for _, sub in ipairs(BLACKLIST_SUBSTRINGS) do
		if hasKeyword(id, sub) or hasKeyword(name, sub) then
			return false
		end
	end

	if isSealed == true then
		if extraClosedBottles[id] then
			return 2, 1
		end
		if openBottles[id] then
			return false
		end
		for _, sub in ipairs(INVENTORY_SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 2, 1
			end
		end
	elseif isSealed == false then
		if openBottles[id] then
			return 0.6, 0.35
		end
		for _, sub in ipairs(ZERO_CHANCE_SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 0, 0.75
			end
		end
		for _, sub in ipairs(LOW_CHANCE_SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 0.3, 0.75
			end
		end
		for _, sub in ipairs(SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 0.6, 0.75
			end
		end
		if extraClosedBottles[id] then
			return 1.5, 1.5
		end
	else
		if openBottles[id] then
			return 0.6, 0.35
		end
		for _, sub in ipairs(ZERO_CHANCE_SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 0, 0.75
			end
		end
		for _, sub in ipairs(LOW_CHANCE_SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 0.3, 0.75
			end
		end
		for _, sub in ipairs(INVENTORY_SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 1.5, 1.5
			end
		end
		for _, sub in ipairs(SUBSTRINGS) do
			if hasKeyword(id, sub) or hasKeyword(name, sub) then
				return 0.99, 0.75
			end
		end
		if extraClosedBottles[id] then
			return 1.5, 1.5
		end
	end
	return false
end

local function categorizeVessel(rec)
	if not rec then
		return ""
	end

	local id   = rec.id
	local name = (rec.name or ''):lower()

	if rec.mwscript then
		return ""
	end
	for _, sub in ipairs(BLACKLIST_SUBSTRINGS) do
		if hasKeyword(id, sub) or hasKeyword(name, sub) then
			return ""
		end
	end
	if extraClosedBottles[id] then
		return "closed bottle"
	end
	if openBottles[name] then
		return "open bottle"
	end
	for _, sub in ipairs(INVENTORY_SUBSTRINGS) do
		if hasKeyword(id, sub) or hasKeyword(name, sub) then
			return "closed bottle"
		end
	end
	for _, sub in ipairs(ZERO_CHANCE_SUBSTRINGS) do
		if hasKeyword(id, sub) or hasKeyword(name, sub) then
			return "open container"
		end
	end
	for _, sub in ipairs(LOW_CHANCE_SUBSTRINGS) do
		if hasKeyword(id, sub) or hasKeyword(name, sub) then
			return "open container"
		end
	end
	for _, sub in ipairs(SUBSTRINGS) do
		if hasKeyword(id, sub) or hasKeyword(name, sub) then
			return "open drink " .. sub
		end
	end
	return ""
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Vessel Capacity													  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function fallbackLitersFrom(rec)
	local id   = rec.id
	local name = (rec.name or ''):lower()
	local chosen
	local chosenL = nil

	for k, L in pairs(FALLBACK_LITERS) do
		if hasKeyword(id, k) or hasKeyword(name, k) then
			if not chosenL or L > chosenL then
				chosen  = k
				chosenL = L
			end
		end
	end

	if chosenL then
		--log(5, "[WaterBottles] Fallback volume for " .. rec.id .. " = " .. trimZeros(chosenL) .. " L")
		return chosenL
	end

	return 1.0
end

local function litersFor(origIdLower)
	local ok, db = pcall(function()
		return dbConsumables
	end)

	if ok and db then
		local row = db[origIdLower]
		if row and type(row.volume) == 'number' and row.volume > 0 then
			return row.volume
		end
	end

	local miscRec = types.Miscellaneous.record(origIdLower)
	if miscRec then
		return fallbackLitersFrom(miscRec)
	end

	return 1.0
end

local function ceildiv(n, d)
	return math.floor((n + d - 1) / d)
end

local function fmt_amount_ml(ml)
	if ml >= 1000 then
		local liters = ml / 1000
		return trimZeros(liters) .. "L"
	end
	return tostring(ml) .. " ml"
end

local function resolveMaxQ(origIdLower)
	local q = saveData.maxQ[origIdLower]
	if q then
		return q
	end

	local liters	 = litersFor(origIdLower)
	local capacityMl = math.max(STEP_ML, math.floor(liters * 1000 + 0.5))
	q = math.max(1, ceildiv(capacityMl, STEP_ML))
	saveData.maxQ[origIdLower] = q

	--log(5, "[WaterBottles] maxQ for " .. origIdLower .. " = " .. tostring(q) ..	" (" .. fmt_amount_ml(q * STEP_ML) .. " capacity)")
	return q
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Liquid Helpers														  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function ensureLiquidDB(liquidKey)
	if not saveData.liquidDB[liquidKey] then
		saveData.liquidDB[liquidKey] = {}
	end
	return saveData.liquidDB[liquidKey]
end

-- Weighted choice with interior v exterior bias  
local function chooseLiquidFor(origIdLower, containerType)
	local vQ		 = resolveMaxQ(origIdLower)
	local pool	  	 = {}
	local total	 	 = 0
	
	
	if vesselLiquids[origIdLower] and containerType ~= "Container" then
		return vesselLiquids[origIdLower][math.random(1, #vesselLiquids[origIdLower])]
	end
	
	local vesselType = categorizeVessel(types.Miscellaneous.records[origIdLower])
	local exp		 = 1
	
-- high chance regardless of interior or exterior
	if vesselType:find("open") and isExterior then
		-- outside - Stronger bias to non-water if open
		exp = 2
	elseif vesselType:find("open drink") and not isExterior then
		-- inside cups lean back to water a bit
		exp = 0.99
	end

	for key, def in pairs(LIQUIDS) do
		if vQ <= def.maxVolumeQ and def.spawnChance > 0 then
			if not isExterior and exp == 0.99 and key == "water" then
				local w = def.spawnChance * 0.1
				total = total + w
				pool[#pool + 1] = { key = key, w = w }
			else
				local w = def.spawnChance ^ exp
				total = total + w
				pool[#pool + 1] = { key = key, w = w }
			end
		end
	end

	-- fallback for edge cases. nod to the well
	if isSealed == 0.3 or #pool == 0 then
		--log(5, "[WaterBottles]", origIdLower, "Fallback liquid -> water")
		return 'water'
	end

	local r, acc = math.random() * total, 0
	for _, e in ipairs(pool) do
		acc = acc + e.w
		if r <= acc then
			return e.key
		end
	end

	return pool[#pool].key
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Record Creation													  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function ensurePotionFor(origIdLower, q, liquidKey)
	local def = LIQUIDS[liquidKey or 'water']
	if not def then
		def = LIQUIDS.water
	end

	local maxQ = resolveMaxQ(origIdLower)
	if q < 1 then
		q = 1
	elseif q > maxQ then
		q = maxQ
	end

	local liquidDB  = ensureLiquidDB(liquidKey or 'water')
	liquidDB[origIdLower] = liquidDB[origIdLower] or {}
	local existing  = liquidDB[origIdLower][q]
	if existing then
		return existing
	end

	local tmpl = types.Potion.record(def.templateId)
	if not tmpl then
		log(1, "[WaterBottles] ERROR: template potion missing: " .. tostring(def.templateId))
		return nil
	end

	local miscRec = types.Miscellaneous.record(origIdLower)
	if not miscRec then
		log(1, "[WaterBottles] ERROR: misc record missing: " .. tostring(origIdLower))
		return nil
	end

	local baseMl   = maxQ * STEP_ML
	local leftMl   = q * STEP_ML
	local nameBase = (miscRec.name and miscRec.name ~= '') and miscRec.name or 'Liquid Container'
	if saveData.newLiquidNaming then
		nameBase = " "..nameBase
		if (liquidKey or 'water') == 'water' then
			nameBase = " "..nameBase
		end
	end
	local newName  = nameBase .. " (" .. fmt_amount_ml(leftMl) .. "/" .. fmt_amount_ml(baseMl) .. " " .. def.displayName .. ")"
	local newWeight = (miscRec.weight or tmpl.weight) + leftMl / 1000
	local newValue  = (miscRec.value or 0) + q * (def.valuePerQ or 1)

	local recordDraft = types.Potion.createRecordDraft({
		name	= newName,
		template= tmpl,
		model   = (miscRec.model and miscRec.model ~= '') and miscRec.model or tmpl.model,
		icon	= (miscRec.icon and miscRec.icon ~= '') and miscRec.icon or tmpl.icon,
		weight  = newWeight,
		value   = newValue,
	})

	local rec  = world.createRecord(recordDraft)
	local newId = rec.id

	liquidDB[origIdLower][q] = newId
	saveData.reverse[newId] = { orig = origIdLower, q = q, liquid = liquidKey or 'water' }
	--log(4, "[WaterBottles] Created record " .. newId .. " for " .. origIdLower .. " q=" .. tostring(q) .. "/" .. tostring(maxQ) .. " [" .. (liquidKey or 'water') .. "]")
	
	--for _, player in pairs(world.players) do
	--	player:sendEvent("SunsDusk_addLiquid", { newId, saveData.reverse[newId]})
	--end

	return newId
end

local function randomFillQ(maxQ, avg)
	local u	= math.random()
	local mode = avg
	local fill

	if u < mode then
		fill = math.sqrt(u * mode)
	else
		fill = 1 - math.sqrt((1 - u) * (1 - mode))
	end

	local q = math.max(1, math.floor(fill * maxQ + 0.5))
	return q
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Replacements														  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function replaceWorldObjectWithFull(obj)
	local rec = types.Miscellaneous.record(obj)
	local chance, averageFillLevel = isVesselRecord(rec)

	if not chance or math.random() > chance * WATER_SPAWN_CHANCE / 100 then
		return 0
	end

	local origId	= rec.id
	local liquidKey = chooseLiquidFor(origId, "World")
	local newId	 = ensurePotionFor(origId, randomFillQ(resolveMaxQ(origId), averageFillLevel), liquidKey)

	if not newId then
		return 0
	end

	local cell  = obj.cell
	local pos   = obj.position
	local rot   = obj.rotation
	local owner = obj.owner
	local count = (obj.count or 1)

	obj:remove()
	local newItem = world.createObject(newId, count)
	newItem.owner.factionId  = owner.factionId
	newItem.owner.factionRank= owner.factionRank
	newItem.owner.recordId   = owner.recordId
	newItem:teleport(cell, pos, rot)

	return count
end

local function replaceInInventory(inv, cont, containerType)
    local Misc      = types.Miscellaneous
    local replaced  = 0
    if cont and types.Container.record(cont).isOrganic then
        return 0
    end

	if not inv:isResolved() and (not cont or not types.Container.record(cont).isOrganic) then
		inv:resolve()
	end

	for _, item in ipairs(inv:getAll(Misc)) do
		if item:isValid() and item.count > 0 then
			local rec = Misc.record(item)
			local chance, averageFillLevel = isVesselRecord(rec, true)

			if chance and math.random() < chance * WATER_SPAWN_CHANCE / 100 then
				local origId	= rec.id
				local liquidKey = chooseLiquidFor(origId, containerType)
				local fullId	= ensurePotionFor(origId, resolveMaxQ(origId), liquidKey)

				if fullId then
					local count = item.count
					item:remove()
					world.createObject(fullId, count):moveInto(inv)
					replaced = replaced + count
				end
			end
		end
	end

	if replaced > 0 then
		--log(5, "[WaterBottles] Inventory replaced " .. tostring(replaced) .. " items")
	end

	return replaced
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ NPC Stocking														  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function addFullToClassNPC(npc)

	-- Original logic preserved for future use
	local cls = (types.NPC.record(npc).class or ''):lower()
	if cls ~= 'publican' and cls ~= 'trader' then
		return false
	end

	local anyOrig
	if cls == 'publican' then
		for orig, _ in pairs(saveData.maxQ) do
			if (orig:find('flask') or orig:find('bottle') or orig:find('flask') or
				orig:find('cup') or orig:find('goblet') or orig:find('pitcher') or orig:find('tankard'))
				and math.random() < 0.3 then
				anyOrig = orig
				break
			end
		end
	else
		for orig, _ in pairs(saveData.maxQ) do
			if orig:find('bottle') and math.random() < 0.5 then
				anyOrig = orig
				break
			end
		end
	end

	if not anyOrig then
		return false
	end

	local liquidKey = chooseLiquidFor(anyOrig, "Restock")
	local fullId = ensurePotionFor(anyOrig, resolveMaxQ(anyOrig), liquidKey)
	if not fullId then
		return false
	end

	local inv = types.NPC.inventory(npc)
	local rndAmount = math.random(1, 5)
	world.createObject(fullId, rndAmount):moveInto(inv)
	log(5, "[WaterBottles] Stocked " .. tostring(rndAmount) .. " bottles to " .. npc.id)
	return true
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Downgrade															  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function downgradeWaterItem(data)
	local item   = data.item
	local inv	= data.inv
	local player = data.player

	if not inv then
		inv = types.NPC.inventory(player)
	end

	local idLower = item.recordId
	local rev	 = saveData.reverse[idLower]
	if not rev then
		return false
	end

	--if item:isValid() and item.count > 0 then
	--	item:remove(1)
	--end

	local nextQ = rev.q - 1
	if nextQ >= 1 then
		local nextId = ensurePotionFor(rev.orig, nextQ, rev.liquid or 'water')
		if nextId then
			world.createObject(nextId):moveInto(inv)
		end
		log(5, "[WaterBottles] Drank " .. (rev.liquid or 'water') .. ": " .. rev.orig .. " -> q=" .. tostring(nextQ))
	else
		world.createObject(rev.orig):moveInto(inv)
		log(5, "[WaterBottles] Emptied " .. (rev.liquid or 'water') .. ": " .. rev.orig .. " -> original misc")
	end

	player:sendEvent("SunsDusk_WaterBottles_consumedWater", rev.liquid or 'water')
	return true
end

function consumeMilliliters(player, mlToConsume, liquidType)
	if not player or not mlToConsume or mlToConsume <= 0 then
		return 0
	end
	liquidType = liquidType or "water"
	local mlConsumed = 0
	local inventory = types.Actor.inventory(player)
	
	-- Collect all liquid items and categorize them
	local openVessels = {}
	local closedVessels = {}
	
	for _, item in pairs(inventory:getAll()) do
		local pid = item.recordId:lower()
		local info = saveData.reverse[pid]
		if info and info.orig and info.q and info.liquid == liquidType then
			-- Get the original vessel record and categorize it
			local origRecord = types.Miscellaneous.record(info.orig)
			if origRecord then
				local category = categorizeVessel(origRecord)
				
				if category and category:find("open") then
					table.insert(openVessels, {item = item, pid = pid, info = info})
				else
					table.insert(closedVessels, {item = item, pid = pid, info = info})
				end
			end
		end
	end
	
	log(5, string.format("Found %d open, %d closed vessels", #openVessels, #closedVessels))
	
	-- Process a list of vessels
	local function processVessels(vesselList)
		for _, data in ipairs(vesselList) do
			if mlConsumed >= mlToConsume then
				break
			end
			
			local item = data.item
			local pid = data.pid
			local info = data.info
			local count = item.count
			
			for i = 1, count do
				
				if mlConsumed >= mlToConsume then
					break
				end
				
				local mlInBottle = info.q * STEP_ML
				local mlNeeded = mlToConsume - mlConsumed
				local mlToTake = math.min(mlInBottle, mlNeeded)
				local qToRemove = math.ceil(mlToTake / STEP_ML)
				local newQ = info.q - qToRemove
				local rev = saveData.reverse[pid]
				
				-- Remove current bottle
				item:remove(1)
				
				-- Add downgraded bottle if not empty
				if newQ > 0 then
					local liquid = info.liquid or 'water'
					local liquidDB = saveData.liquidDB[liquid]
					
					local newId = ensurePotionFor(rev.orig, newQ, rev.liquid)
					if newId then
						world.createObject(newId, 1):moveInto(inventory)
					end					
				else
					world.createObject(info.orig, 1):moveInto(inventory)
				end
				mlConsumed = mlConsumed + mlToTake
			end
		end
	end
	
	-- Process open vessels first, then closed
	processVessels(openVessels)
	
	if mlConsumed < mlToConsume then
		processVessels(closedVessels)
	end
	
	log(4, string.format("Consumed %d/%d ml from player inventory", mlConsumed, mlToConsume))
	
	return mlConsumed
end

-- Consume water from inventory, prioritizing open vessels
local function consumeWater(data)
	local player = data.player
	local amountMl = data.amountMl or 250
	consumeMilliliters(player, amountMl)
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Cell Conversion													  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function convertMiscInCell(data)
	local cell = data.player.cell
	isExterior = cell:hasTag("QuasiExterior") or cell.isExterior

	if saveData.convertedCellsWater[cell.id] then
		return
	end

	local converted = 0
	local stocked   = 0

	for _, obj in ipairs(cell:getAll(types.Miscellaneous)) do
		if obj:isValid() and (obj.count or 1) > 0 then
			converted = converted + replaceWorldObjectWithFull(obj)
		end
	end

	for _, c in ipairs(cell:getAll(types.Container)) do
		converted = converted + replaceInInventory(types.Container.inventory(c), c, "Container")
	end

	for _, npc in ipairs(cell:getAll(types.NPC)) do
		local idLower = npc.id
		if not saveData.convertedNPCsWater[idLower] then
			converted = converted + replaceInInventory(types.NPC.inventory(npc), nil, "NPC")

			if addFullToClassNPC(npc) then
				stocked = stocked + 1
			end

			saveData.convertedNPCsWater[idLower] = true
		end
	end

	for _, cr in ipairs(cell:getAll(types.Creature)) do
		converted = converted + replaceInInventory(types.Creature.inventory(cr), nil, "Creature")
	end

	if converted > 0 then
		log(3, "[WaterBottles] Converted " .. tostring(converted) .. " items in cell " .. tostring(cell.id))
	end

	if stocked > 0 then
		log(3, "[WaterBottles] Gave bottles to " .. tostring(stocked) .. " NPCs")
	end

	saveData.convertedCellsWater[cell.id] = true
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Spillage															  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function spillWater(player)
	local Misc	  = types.Miscellaneous
	local spilledMl = 0
	local inv	   = types.NPC.inventory(player)
	for _, item in ipairs(inv:getAll(types.Potion)) do
		local rev = saveData.reverse[item.recordId]
		if rev then
			local isBottle = isVesselRecord(Misc.record(rev.orig), true)
			if not isBottle then
				local spillableLiquid = true
				for _, pattern in pairs(unspillableLiquids) do
					if item.type.record(item).name:find(pattern, 1, true) then
						spillableLiquid = false
					end
				end
				if spillableLiquid then
					local quantity = item.count
					local maxQ = resolveMaxQ(rev.orig)
					local targetQ = math.floor(rev.q/2)
					if targetQ >= 1 and rev.q>math.floor(maxQ/2) then
						spilledMl = spilledMl + (rev.q-targetQ) * 250 * quantity
						local newId = ensurePotionFor(rev.orig, targetQ, rev.liquid)
						if newId then
							item:remove()
							world.createObject(newId, quantity):moveInto(inv)
						end
					else
						spilledMl = spilledMl + rev.q * 250 * quantity
						item:remove()
						world.createObject(rev.orig, quantity):moveInto(inv)
					end
				end
			end
		end
	end

	if spilledMl > 0 then
		player:sendEvent("SunsDusk_spilledWater", spilledMl)
	end
end

-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ purify																  │
-- ╰──────────────────────────────────────────────────────────────────────╯

local function purifyWater(data)
	local player = data[1]
	
	local mlPurified = 0
	local inventory = types.Actor.inventory(player)
	
	local dirtyLiquids = {
		saltWater = true,
		susWater = true,
	}
	
	-- Collect all dirty water items
	local dirtyItems = {}
	
	for _, item in pairs(inventory:getAll(types.Potion)) do
		local pid = item.recordId
		local info = saveData.reverse[pid]
		
		if info and info.orig and info.q and dirtyLiquids[info.liquid] then
			table.insert(dirtyItems, {item = item, pid = pid, info = info})
		end
	end
	
	log(5, string.format("Found %d dirty water vessels to purify", #dirtyItems))
	
	local purifiedLiquids = {}
	
	for _, itemData in ipairs(dirtyItems) do
		local item = itemData.item
		local info = itemData.info
		local count = item.count
		local mlInBottle = info.q * STEP_ML
		
		-- Remove all dirty water bottles of this type
		item:remove(count)
		-- Add purified water
		local purifiedId = ensurePotionFor(info.orig, info.q, 'water')
		if purifiedId then
			world.createObject(purifiedId, count):moveInto(inventory)
		end
		
		mlPurified = mlPurified + (mlInBottle * count)
		purifiedLiquids[info.liquid] = (purifiedLiquids[info.liquid] or 0) + (mlInBottle * count)
	end
	
	log(4, string.format("Purified %dml of dirty water", mlPurified))
	player:sendEvent("SunsDusk_WaterBottles_waterPurified", purifiedLiquids)
end


-- ╭──────────────────────────────────────────────────────────────────────╮
-- │ Refilling															  │
-- ╰──────────────────────────────────────────────────────────────────────╯

-- Starwind ; Saltwater, Sus water
local function refillBottlesWell(data)
	local player = data[1]
	local liquidType = data[2] or 'water'
	local inv	= types.NPC.inventory(player)
	local Misc   = types.Miscellaneous
	local Potion = types.Potion

	local replaced = 0

	for _, item in ipairs(inv:getAll(Misc)) do
		if item:isValid() and item.count > 0 then
			local rec	= Misc.record(item)
			local chance = isVesselRecord(rec, true)

			if chance then
				local origId = rec.id
				local fullId = ensurePotionFor(origId, resolveMaxQ(origId), liquidType)
				
				if fullId then
					local count = item.count
					item:remove()
					world.createObject(fullId, count):moveInto(inv)
					replaced = replaced + count
				end
			end
		end
	end
	
	
	for _, item in ipairs(inv:getAll(Potion)) do
		if item:isValid() and item.count > 0 then
			local rev = saveData.reverse[item.recordId]
			if rev then
				local origId = rev.orig
				local maxQ   = resolveMaxQ(origId)
				local fullId = ensurePotionFor(origId, maxQ, liquidType)
				
				if maxQ and rev.q < maxQ and fullId then
					local count = item.count
					item:remove()
					world.createObject(fullId, count):moveInto(inv)
					replaced = replaced + count
				end
			end
		end
	end
	local data = { 
		["replaced"]  	= replaced,
		["liquidType"]  = liquidType,
	}
	
	player:sendEvent("SunsDusk_refilledBottlesWell", data)

end

-- open sources only refill spillables; keep water
local function refillSpillables(data)
	local player = data[1]
	local liquidType = data[2] or 'water'
	
	local inv	= types.NPC.inventory(player)
	local Misc   = types.Miscellaneous
	local Potion = types.Potion

	local replaced = 0

	for _, item in ipairs(inv:getAll(Misc)) do
		if item:isValid() and item.count > 0 then
			local rec   = Misc.record(item)
			local isOpen = isVesselRecord(rec, false)
			if isOpen then
				local origId = rec.id
				local fullId = ensurePotionFor(origId, resolveMaxQ(origId), liquidType)

				if fullId then
					local count = item.count
					item:remove()
					world.createObject(fullId, count):moveInto(inv)
					replaced = replaced + count
				end
			end
		end
	end

	for _, item in ipairs(inv:getAll(Potion)) do
		if item:isValid() and item.count > 0 then
			local rev = saveData.reverse[item.recordId]
			if rev then
				local origId = rev.orig
				local isOpen = isVesselRecord(Misc.records[origId], false)

				if isOpen then
					local maxQ   = resolveMaxQ(origId)
					local fullId = ensurePotionFor(origId, maxQ, liquidType)

					if maxQ and rev.q < maxQ and fullId then
						local count = item.count
						item:remove()
						world.createObject(fullId, count):moveInto(inv)
						replaced = replaced + count
					end
				end
			end
		end
	end

	if replaced > 0 then
		local str = "Refilled " .. tostring(replaced) .. " bottles with " .. tostring(LIQUIDS[liquidType]["displayName"])
		player:sendEvent("SunsDusk_messageBox", { 3, str })
	end
end

G_onLoadJobs.liquids = function(data)

	saveData.maxQ					= saveData.maxQ					or {}
	saveData.reverse				= saveData.reverse				or {}
	saveData.convertedCellsWater	= saveData.convertedCellsWater	or {}
	saveData.convertedNPCsWater		= saveData.convertedNPCsWater	or {}
	
	if data then
		saveData.newLiquidNaming = false
	else
		saveData.newLiquidNaming = true
	end

	-- migration and container sanity
	if not saveData.liquidDB then
		saveData.liquidDB = {}
	
		if saveData.waterDB then
			saveData.liquidDB.water = saveData.waterDB
			saveData.waterDB = nil
		else
			saveData.liquidDB.water = {}
		end
		
		for pid, info in pairs(saveData.reverse) do
			if info and info.orig and info.q and not info.liquid then
				info.liquid = 'water'
			end
		end
	end
	
	-- Migration: Fix old lowercase "generated:..." to "Generated:..."
	if not saveData.fixedGeneratedCase then
		local keysToFix = {}
		for key in pairs(saveData.reverse) do
			if key:sub(1, 10) == "generated:" then
				table.insert(keysToFix, key)
			end
		end
		
		for _, oldKey in ipairs(keysToFix) do
			local newKey = "G" .. oldKey:sub(2)  -- Replace 'g' with 'G'
			saveData.reverse[newKey] = saveData.reverse[oldKey]
			saveData.reverse[oldKey] = nil
		end
		
		if #keysToFix > 0 then
			log(3, string.format("[Liquids Migration] Fixed %d generated ID keys from lowercase to uppercase", #keysToFix))
		end
		
		saveData.fixedGeneratedCase = true
	end
end

G_eventHandlers.SunsDusk_WaterBottles_convertMiscInCell		= convertMiscInCell
G_eventHandlers.SunsDusk_WaterBottles_downgradeWaterItem	= downgradeWaterItem
G_eventHandlers.SunsDusk_WaterBottles_spillWater			= spillWater
G_eventHandlers.SunsDusk_WaterBottles_refillBottlesWell		= refillBottlesWell
G_eventHandlers.SunsDusk_WaterBottles_refillSpillables		= refillSpillables
G_eventHandlers.SunsDusk_WaterBottles_consumeWater			= consumeWater
G_eventHandlers.SunsDusk_WaterBottles_purifyWater			= purifyWater